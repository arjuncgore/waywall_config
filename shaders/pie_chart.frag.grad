precision highp float;
varying vec2 f_src_pos;
uniform sampler2D u_texture;

const float threshold = 0.01;

// SRC COLORS
const vec3 blockentities    = vec3(0.925, 0.431, 0.306);
const vec3 entities         = vec3(0.894, 0.275, 0.769);
const vec3 unspecified      = vec3(0.275, 0.808, 0.400);
const vec3 destroyProgress  = vec3(0.800, 0.424, 0.275);
const vec3 prepare          = vec3(0.275, 0.298, 0.275);

// DST COLORS
const vec4 primary_color    = vec4(0.153, 0.141, 0.125, 1.000);
const vec4 secondary_color  = vec4(0.529, 0.463, 0.396, 1.000);

void main() {
    vec4 color = texture2D(u_texture, f_src_pos);

    bool is_entities       = all(lessThan(abs(color.rgb - entities),        vec3(threshold)));
    bool is_unspecified    = all(lessThan(abs(color.rgb - unspecified),     vec3(threshold)));
    bool is_destroyProgess = all(lessThan(abs(color.rgb - destroyProgress), vec3(threshold)));
    bool is_prepare        = all(lessThan(abs(color.rgb - prepare),         vec3(threshold)));
    bool is_blockentities  = all(lessThan(abs(color.rgb - blockentities),   vec3(threshold)));

    // === RADIAL GRADIENT ===
    vec2 centered = f_src_pos * 2.0 - 1.0;
    float dist = length(centered);
    float t = smoothstep(0.0, 1.0, dist);

    vec4 grad1_inner = primary_color;
    vec4 grad2_inner = secondary_color;
    vec4 grad_outer = vec4(0.5, 0.5, 0.5, 1.0);

    vec4 gradient1   = mix(grad1_inner, grad_outer, t);
    vec4 gradient2   = mix(grad2_inner, grad_outer, t);

    if ( is_entities || is_unspecified || is_destroyProgess || is_prepare ) {
        gl_FragColor = gradient2;
    }
    else if ( is_blockentities ) {
        gl_FragColor = gradient1;
    }
    else {
        gl_FragColor = vec4(0.0);
    }
}

